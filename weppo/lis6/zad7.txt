HelloWorld
type HelloWorld = string

Pick
type MyPick<T, K extends keyof T> = {
    [key in K]: T[key]
}

Readonly
type MyReadonly<T> = {
    readonly [P in keyof T]: T[P];
}

TupleToObject
type TupleToObject<T extends readonly PropertyKey[]> = {
    [P in T[number]]: P
}

First of array
type First<T extends any[]> = T extends [] ? never : T[0]

Length of tuple
type Length<T extends readonly any[]> = T['length']

Exclude
type MyExclude<T, U> = T extends U ? never : T

awaited
type Awaited<T> = T extends Promise<infer U> ? U : never

if
type If<C extends boolean, T, F> = C extends true ? T : F

Concat
type Concat<T extends any[], U extends any[]> = [...T, ...U]

Includes
type Includes<T extends readonly any[], U> = true extends {
    [I in keyof T]: Equal<T[I], U>
  }[number] ? true : false

Push
type Push<T extends any[], U> = [...T, U]

Unshift
type Unshift<T extends any[], U> = [U, ...T]

parameters
type MyParameters<T> = T extends (...args: infer P) => any ? P : never
